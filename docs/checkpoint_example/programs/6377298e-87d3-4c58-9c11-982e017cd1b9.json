{"id": "6377298e-87d3-4c58-9c11-982e017cd1b9", "code": "# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\n\ndef search_algorithm(iterations=1000, bounds=(-5, 5)):\n    \"\"\"\n    An improved search algorithm using simulated annealing to escape local minima.\n    \n    Args:\n        iterations: Number of iterations to run\n        bounds: Bounds for the search space (min, max)\n        \n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    # Initialize with a random point\n    current_x = np.random.uniform(bounds[0], bounds[1])\n    current_y = np.random.uniform(bounds[0], bounds[1])\n    current_value = evaluate_function(current_x, current_y)\n    \n    best_x, best_y, best_value = current_x, current_y, current_value\n    temperature = 1.0\n    initial_cooling_rate = 0.98\n    cooling_rate = initial_cooling_rate\n    improvement_factor = 0.95  # Factor to reduce cooling rate if no improvement\n    min_temperature = 1e-5  # Lower minimum temperature for finer search\n    stagnation_limit = 200  # Iterations before considering stagnation\n\n    for _ in range(iterations):\n        # Generate a new candidate point by adding a small perturbation\n        # Dynamic perturbation scale based on distance from best known point\n        distance_to_best = np.sqrt((current_x - best_x)**2 + (current_y - best_y)**2)\n        perturbation_scale = max(0.2 * temperature, (iterations - _) / iterations)\n        new_x = current_x + np.random.uniform(-perturbation_scale, perturbation_scale)\n        new_y = current_y + np.random.uniform(-perturbation_scale, perturbation_scale)\n        new_value = evaluate_function(new_x, new_y)\n\n        # Calculate acceptance probability\n        if new_value < current_value:\n            accept = True\n        else:\n            accept = np.exp((current_value - new_value) / temperature) > np.random.rand()\n        \n        # Accept the new solution\n        if accept:\n            current_x, current_y, current_value = new_x, new_y, new_value\n\n        # Update the best solution found\n        if current_value < best_value:\n            best_x, best_y, best_value = current_x, current_y, current_value\n\n        # Cool down the temperature\n        # Implement a restart mechanism if no improvement is found in a certain number of iterations\n        # Check for stagnation and adapt cooling rate\n        if _ % stagnation_limit == 0:\n            if current_value >= best_value:\n                current_x = np.random.uniform(bounds[0], bounds[1])\n                current_y = np.random.uniform(bounds[0], bounds[1])\n                current_value = evaluate_function(current_x, current_y)\n                cooling_rate *= improvement_factor  # Decrease cooling rate to allow more exploration\n            else:\n                cooling_rate = initial_cooling_rate  # Reset cooling rate on improvement\n            current_x = np.random.uniform(bounds[0], bounds[1])\n            current_y = np.random.uniform(bounds[0], bounds[1])\n            current_value = evaluate_function(current_x, current_y)\n        \n        temperature = max(temperature * cooling_rate, min_temperature)\n    \n    return best_x, best_y, best_value\n\ndef evaluate_function(x, y):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x) * np.cos(y) + np.sin(x*y) + (x**2 + y**2)/20\n# EVOLVE-BLOCK-END\n\n# This part remains fixed (not evolved)\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n    # The global minimum is around (-1.76, -1.03) with value -2.104\n", "language": "python", "parent_id": "d739b8c2-8dcc-41d6-bf83-eec8e490a417", "generation": 5, "timestamp": 1747683930.056656, "metrics": {"runs_successfully": 1.0, "value": -0.5305748189281594, "distance": 2.8944020275163918, "value_score": 0.5990563369091026, "distance_score": 0.30363374633029705, "overall_score": 0.5101047852089102, "speed_score": 1.0, "reliability_score": 1.0, "combined_score": 0.5505239260445507, "success_rate": 1.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace 2 lines with 3 lines\nChange 2: 'perturbation_scale = max(0.1 * temperature, distance_to_best * 0.05)' to 'perturbation_scale = max(0.2 * temperature, (iterations - _) / iterations)'\nChange 3: 'cooling_rate *= 0.9  # Decrease cooling rate to allow more exploration' to 'cooling_rate *= improvement_factor  # Decrease cooling rate to allow more exploration'", "parent_metrics": {"runs_successfully": 1.0, "value": -0.29619770166506365, "distance": 0.8036624705482555, "value_score": 0.46804864930796547, "distance_score": 0.22602127933344787, "overall_score": 0.16972711467696272, "speed_score": 1.0, "reliability_score": 1.0, "combined_score": 0.4486355733848136, "success_rate": 1.0}},"prompts": {"prompt_0": "You are an expert in evolutionary algorithms. Your task is to improve the search algorithm for a complex function minimization problem. The current implementation uses a basic simulated annealing approach. Your goal is to enhance the algorithm's performance by making it more efficient and robust against local minima. Consider introducing dynamic perturbation scales, adaptive cooling rates, and mechanisms to escape local minima effectively.", "prompt_1": "The current search algorithm is designed to minimize a complex function. It uses simulated annealing with a fixed perturbation scale and cooling rate. Your task is to improve this algorithm by making it more adaptive to the search space. Consider implementing dynamic perturbation scales based on the distance from the best known point, adaptive cooling rates that respond to the search progress, and mechanisms to escape local minima effectively.", "prompt_2": "The current search algorithm is designed to minimize a complex function. It uses simulated annealing with a fixed perturbation scale and cooling rate. Your task is to improve this algorithm by making it more adaptive to the search space. Consider implementing dynamic perturbation scales based on the distance from the best known point, adaptive cooling rates that respond to the search progress, and mechanisms to escape local minima effectively."}}