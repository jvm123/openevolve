{"id": "eb97324d-0ef0-4464-9922-a74cb1211ce4", "code": "# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\n\ndef search_algorithm(iterations=1000, bounds=(-5, 5)):\n    \"\"\"\n    Global minimum search using hybrid Differential Evolution + Simulated Annealing.\n    \"\"\"\n    # Differential Evolution parameters\n    pop_size = 15\n    F = 0.7\n    CR = 0.9\n    dim = 2\n    np.random.seed(None)\n    pop = np.random.uniform(bounds[0], bounds[1], (pop_size, dim))\n    fitness = np.array([evaluate_function(ind[0], ind[1]) for ind in pop])\n    best_idx = np.argmin(fitness)\n    best_x, best_y, best_value = pop[best_idx,0], pop[best_idx,1], fitness[best_idx]\n\n    for gen in range(int(iterations*0.6)):\n        for i in range(pop_size):\n            idxs = [idx for idx in range(pop_size) if idx != i]\n            a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n            mutant = np.clip(a + F * (b - c), bounds[0], bounds[1])\n            cross_points = np.random.rand(dim) < CR\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, dim)] = True\n            trial = np.where(cross_points, mutant, pop[i])\n            trial_value = evaluate_function(trial[0], trial[1])\n            if trial_value < fitness[i]:\n                pop[i] = trial\n                fitness[i] = trial_value\n                if trial_value < best_value:\n                    best_x, best_y, best_value = trial[0], trial[1], trial_value\n\n    # Simulated Annealing local refinement around best found\n    current_x, current_y = best_x, best_y\n    current_value = best_value\n    temperature = 1.0\n    cooling_rate = 0.993\n    for i in range(int(iterations*0.4)):\n        perturbation_size = max(0.05, temperature / 4.0)\n        new_x = np.clip(current_x + np.random.uniform(-perturbation_size, perturbation_size), bounds[0], bounds[1])\n        new_y = np.clip(current_y + np.random.uniform(-perturbation_size, perturbation_size), bounds[0], bounds[1])\n        new_value = evaluate_function(new_x, new_y)\n        if new_value < current_value:\n            current_x, current_y, current_value = new_x, new_y, new_value\n            if current_value < best_value:\n                best_x, best_y, best_value = current_x, current_y, current_value\n        else:\n            if np.exp((current_value - new_value) / temperature) > np.random.rand():\n                current_x, current_y, current_value = new_x, new_y, new_value\n        temperature *= cooling_rate\n\n    return best_x, best_y, best_value\n\ndef evaluate_function(x, y):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x) * np.cos(y) + np.sin(x*y) + (x**2 + y**2)/20\n# EVOLVE-BLOCK-END\n\n# This part remains fixed (not evolved)\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n    # The global minimum is around (-1.76, -1.03) with value -2.104\n", "language": "python", "parent_id": "706d13f2-4663-46f6-93b6-78fcf043b2db", "generation": 3, "timestamp": 1747683972.4791572, "metrics": {"runs_successfully": 1.0, "value": -1.518685840848579, "distance": 1.708423153547417, "value_score": 0.6307897991242789, "distance_score": 0.3692185243248374, "overall_score": 0.5}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace 48 lines with 51 lines", "parent_metrics": {"runs_successfully": 1.0, "value": -1.4204747531363051, "distance": 5.192335910281548, "value_score": 0.5939457760826873, "distance_score": 0.22030065048037717, "overall_score": 0.18449153215874511, "speed_score": 1.0, "reliability_score": 1.0, "combined_score": 0.5224576607937255, "success_rate": 1.0}}}