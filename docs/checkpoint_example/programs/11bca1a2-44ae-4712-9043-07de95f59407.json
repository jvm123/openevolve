{"id": "11bca1a2-44ae-4712-9043-07de95f59407", "code": "# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\n\ndef search_algorithm(iterations=1000, bounds=(-5, 5)):\n    \"\"\"\n    Hybrid global optimization using Simulated Annealing with periodic random restarts and population-based exploration.\n    \"\"\"\n    # Parameters for population and exploration\n    population_size = 4\n    population = []\n    for _ in range(population_size):\n        x = np.random.uniform(bounds[0], bounds[1])\n        y = np.random.uniform(bounds[0], bounds[1])\n        v = evaluate_function(x, y)\n        population.append({'x': x, 'y': y, 'v': v, 'cx': x, 'cy': y, 'cv': v, 't': 1.0})\n\n    cooling_rate = 0.997\n    min_temperature = 1e-4\n    restart_interval = iterations // 4\n    best_x, best_y, best_value = population[0]['x'], population[0]['y'], population[0]['v']\n\n    for it in range(iterations):\n        for ind in population:\n            # Adaptive perturbation: larger when temp is high or early in search\n            progress_factor = (it / iterations)\n            # Slightly increase scale for global jumps, but decrease as temp drops\n            perturbation_scale = max(0.35 * ind['t'] * (1 - progress_factor)**0.7, 0.015)\n            new_x = ind['x'] + np.random.uniform(-perturbation_scale, perturbation_scale)\n            new_y = ind['y'] + np.random.uniform(-perturbation_scale, perturbation_scale)\n            # Keep within bounds\n            new_x = np.clip(new_x, bounds[0], bounds[1])\n            new_y = np.clip(new_y, bounds[0], bounds[1])\n            new_v = evaluate_function(new_x, new_y)\n            # Accept if better, or with probability if worse\n            if new_v < ind['v']:\n                accept = True\n            else:\n                accept = np.exp((ind['v'] - new_v) / ind['t']) > np.random.rand()\n            if accept:\n                ind['x'], ind['y'], ind['v'] = new_x, new_y, new_v\n            # Track personal best\n            if ind['v'] < ind['cv']:\n                ind['cx'], ind['cy'], ind['cv'] = ind['x'], ind['y'], ind['v']\n            # Global best\n            if ind['v'] < best_value:\n                best_x, best_y, best_value = ind['x'], ind['y'], ind['v']\n            # Anneal\n            ind['t'] = max(ind['t'] * cooling_rate, min_temperature)\n        # Occasional random restart for worst-performing particle\n        if (it+1) % restart_interval == 0:\n            worst = max(population, key=lambda d: d['cv'])\n            # Restart at a new random location or at global best + noise\n            if np.random.rand() < 0.5:\n                rx = np.random.uniform(bounds[0], bounds[1])\n                ry = np.random.uniform(bounds[0], bounds[1])\n            else:\n                rx = best_x + np.random.normal(0, 0.8)\n                ry = best_y + np.random.normal(0, 0.8)\n                rx = np.clip(rx, bounds[0], bounds[1])\n                ry = np.clip(ry, bounds[0], bounds[1])\n            rv = evaluate_function(rx, ry)\n            worst.update({'x': rx, 'y': ry, 'v': rv, 'cx': rx, 'cy': ry, 'cv': rv, 't': 1.0})\n        # Occasional cross-over: share info among population (like in DE or PSO)\n        if (it+1) % 75 == 0:\n            # Pick 2 random individuals and mix their coordinates\n            idx1, idx2 = np.random.choice(population_size, 2, replace=False)\n            ind1, ind2 = population[idx1], population[idx2]\n            # Arithmetic crossover\n            alpha = np.random.rand()\n            cross_x = alpha * ind1['x'] + (1 - alpha) * ind2['x']\n            cross_y = alpha * ind1['y'] + (1 - alpha) * ind2['y']\n            cross_x = np.clip(cross_x, bounds[0], bounds[1])\n            cross_y = np.clip(cross_y, bounds[0], bounds[1])\n            cross_v = evaluate_function(cross_x, cross_y)\n            # Replace worst of the two if new is better\n            if cross_v < max(ind1['v'], ind2['v']):\n                if ind1['v'] > ind2['v']:\n                    ind1['x'], ind1['y'], ind1['v'] = cross_x, cross_y, cross_v\n                else:\n                    ind2['x'], ind2['y'], ind2['v'] = cross_x, cross_y, cross_v\n                # Update personal bests\n                if cross_v < ind1['cv']:\n                    ind1['cx'], ind1['cy'], ind1['cv'] = cross_x, cross_y, cross_v\n                if cross_v < ind2['cv']:\n                    ind2['cx'], ind2['cy'], ind2['cv'] = cross_x, cross_y, cross_v\n\n    return best_x, best_y, best_value\n\ndef evaluate_function(x, y):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x) * np.cos(y) + np.sin(x*y) + (x**2 + y**2)/20\n# EVOLVE-BLOCK-END\n\n# This part remains fixed (not evolved)\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n    # The global minimum is around (-1.76, -1.03) with value -2.104\n", "language": "python", "parent_id": "96538759-e6dd-4e66-9aaf-93c253650715", "generation": 5, "timestamp": 1747684426.4385304, "metrics": {"runs_successfully": 1.0, "value": -1.518289241750869, "distance": 1.6963299022872307, "value_score": 0.6306320334889788, "distance_score": 0.37087449838824416, "overall_score": 0.5}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace 67 lines with 84 lines", "parent_metrics": {"runs_successfully": 1.0, "value": -0.8038628044982474, "distance": 3.777583688551058, "value_score": 0.44793697740459426, "distance_score": 0.1715387091046857, "overall_score": 0.16404475983483247, "speed_score": 1.0, "reliability_score": 1.0, "combined_score": 0.42022379917416225, "success_rate": 1.0}}}