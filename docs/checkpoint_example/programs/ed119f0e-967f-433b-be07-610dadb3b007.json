{"id": "ed119f0e-967f-433b-be07-610dadb3b007", "code": "# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\n\ndef search_algorithm(iterations=1000, bounds=(-5, 5)):\n    \"\"\"\n    Hybrid global optimization using multistart simulated annealing and local search.\n    Improves exploration and escape from local minima.\n    \"\"\"\n    n_starts = 12  # More random restarts for better global search\n    best_overall = None\n    best_value_overall = np.inf\n\n    for start in range(n_starts):\n        # Random initialization for each restart\n        current_x = np.random.uniform(bounds[0], bounds[1])\n        current_y = np.random.uniform(bounds[0], bounds[1])\n        current_value = evaluate_function(current_x, current_y)\n        best_x, best_y, best_value = current_x, current_y, current_value\n\n        # Annealing parameters for this run\n        temperature = 3.0  # Increase starting temperature for better exploration\n        cooling_rate = 0.995  # Even slower cooling to maintain exploration longer\n        local_iter = iterations // n_starts\n\n        for _ in range(local_iter):\n            # Adaptive step size based on temperature\n            step_size = 0.15 * temperature\n            # Propose a new candidate (clip to bounds)\n            new_x = np.clip(current_x + np.random.uniform(-step_size, step_size), bounds[0], bounds[1])\n            new_y = np.clip(current_y + np.random.uniform(-step_size, step_size), bounds[0], bounds[1])\n            new_value = evaluate_function(new_x, new_y)\n\n            # Calculate acceptance probability\n            if new_value < current_value:\n                accept = True\n            else:\n                delta = new_value - current_value\n                accept = np.exp(-delta / max(temperature, 1e-8)) > np.random.rand()\n\n            # Accept or reject\n            if accept:\n                current_x, current_y, current_value = new_x, new_y, new_value\n\n            # Update the best for this run\n            if current_value < best_value:\n                best_x, best_y, best_value = current_x, current_y, current_value\n\n            # Cool down\n            temperature *= cooling_rate\n\n        # After annealing, perform a brief local search (hill climbing)\n        momentum = np.array([0.0, 0.0])\n        alpha = 0.8  # Momentum factor\n        for i in range(15):\n            grad_x = (evaluate_function(best_x + 1e-4, best_y) - evaluate_function(best_x - 1e-4, best_y)) / 2e-4\n            grad_y = (evaluate_function(best_x, best_y + 1e-4) - evaluate_function(best_x, best_y - 1e-4)) / 2e-4\n            # Adaptive step size\n            step = 0.05 / (1 + 0.1 * i)\n            momentum = alpha * momentum - step * np.array([grad_x, grad_y])\n            best_x = np.clip(best_x + momentum[0], bounds[0], bounds[1])\n            best_y = np.clip(best_y + momentum[1], bounds[0], bounds[1])\n            best_value = evaluate_function(best_x, best_y)\n\n        # Track the best overall result\n        if best_value < best_value_overall:\n            best_overall = (best_x, best_y, best_value)\n            best_value_overall = best_value\n\n    return best_overall\n\ndef evaluate_function(x, y):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x) * np.cos(y) + np.sin(x*y) + (x**2 + y**2)/20\n# EVOLVE-BLOCK-END\n\n# This part remains fixed (not evolved)\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n    # The global minimum is around (-1.76, -1.03) with value -2.104\n", "language": "python", "parent_id": "4d5f7a30-9954-49e8-9819-b2415aa9599a", "generation": 3, "timestamp": 1747683665.91339, "metrics": {"runs_successfully": 1.0, "value": -1.5094233905848353, "distance": 1.633414347326884, "value_score": 0.6271257173192608, "distance_score": 0.37973515296408866, "overall_score": 0.5}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace 2 lines with 2 lines\nChange 2: Replace 8 lines with 11 lines", "parent_metrics": {"runs_successfully": 1.0, "value": -1.5065319973050537, "distance": 1.6447942907207354, "value_score": 0.6259906291161944, "distance_score": 0.3781012396724015, "overall_score": 0.5}}}