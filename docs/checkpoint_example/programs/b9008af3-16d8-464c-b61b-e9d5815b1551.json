{"id": "b9008af3-16d8-464c-b61b-e9d5815b1551", "code": "# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\n\ndef search_algorithm(iterations=1000, bounds=(-5, 5)):\n    \"\"\"\n    Hybrid global optimization using multistart simulated annealing and local search.\n    Improves exploration and escape from local minima.\n    \"\"\"\n    n_starts = 12  # More random restarts for better global search\n    best_overall = None\n    best_value_overall = np.inf\n\n    for start in range(n_starts):\n        # Random initialization for each restart\n        current_x = np.random.uniform(bounds[0], bounds[1])\n        current_y = np.random.uniform(bounds[0], bounds[1])\n        current_value = evaluate_function(current_x, current_y)\n        best_x, best_y, best_value = current_x, current_y, current_value\n\n        # Annealing parameters for this run\n        temperature = 2.5  # Slightly higher to encourage more exploration\n        cooling_rate = 0.992  # Slower cooling for better exploration\n        local_iter = iterations // n_starts\n\n        for _ in range(local_iter):\n            # Adaptive step size based on temperature\n            step_size = 0.15 * temperature\n            # Propose a new candidate (clip to bounds)\n            new_x = np.clip(current_x + np.random.uniform(-step_size, step_size), bounds[0], bounds[1])\n            new_y = np.clip(current_y + np.random.uniform(-step_size, step_size), bounds[0], bounds[1])\n            new_value = evaluate_function(new_x, new_y)\n\n            # Calculate acceptance probability\n            if new_value < current_value:\n                accept = True\n            else:\n                delta = new_value - current_value\n                accept = np.exp(-delta / max(temperature, 1e-8)) > np.random.rand()\n\n            # Accept or reject\n            if accept:\n                current_x, current_y, current_value = new_x, new_y, new_value\n\n            # Update the best for this run\n            if current_value < best_value:\n                best_x, best_y, best_value = current_x, current_y, current_value\n\n            # Cool down\n            temperature *= cooling_rate\n\n        # After annealing, perform a brief local search (hill climbing)\n        for _ in range(10):\n            grad_x = (evaluate_function(best_x + 1e-4, best_y) - evaluate_function(best_x - 1e-4, best_y)) / 2e-4\n            grad_y = (evaluate_function(best_x, best_y + 1e-4) - evaluate_function(best_x, best_y - 1e-4)) / 2e-4\n            # Small step in negative gradient direction\n            step = 0.05\n            best_x = np.clip(best_x - step * grad_x, bounds[0], bounds[1])\n            best_y = np.clip(best_y - step * grad_y, bounds[0], bounds[1])\n            best_value = evaluate_function(best_x, best_y)\n\n        # Track the best overall result\n        if best_value < best_value_overall:\n            best_overall = (best_x, best_y, best_value)\n            best_value_overall = best_value\n\n    return best_overall\n\ndef evaluate_function(x, y):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x) * np.cos(y) + np.sin(x*y) + (x**2 + y**2)/20\n# EVOLVE-BLOCK-END\n\n# This part remains fixed (not evolved)\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n    # The global minimum is around (-1.76, -1.03) with value -2.104\n", "language": "python", "parent_id": "4d5f7a30-9954-49e8-9819-b2415aa9599a", "generation": 3, "timestamp": 1747683586.5373564, "metrics": {"runs_successfully": 1.0, "value": -1.50959634457388, "distance": 1.6769128227779755, "value_score": 0.6271937451954349, "distance_score": 0.37356464935688366, "overall_score": 0.5}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: 'n_starts = 12  # More random restarts for better global search' to 'n_starts = 20  # Increase number of random restarts for broader search'\nChange 2: Replace 2 lines with 2 lines\nChange 3: 'step_size = 0.15 * temperature' to 'step_size = 0.2 * temperature  # Increase step size for broader moves'\nChange 4: Replace 5 lines with 5 lines", "parent_metrics": {"runs_successfully": 1.0, "value": -1.5065319973050537, "distance": 1.6447942907207354, "value_score": 0.6259906291161944, "distance_score": 0.3781012396724015, "overall_score": 0.5}}}